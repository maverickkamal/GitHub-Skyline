use std::fs;
use colored::*;

pub fn save_skyline_to_file(
    skyline_output: &str, 
    filename: &str, 
    username: &str, 
    theme: &str,
    total_contributions: u32
) -> Result<(), Box<dyn std::error::Error>> {
    let mut file_content = String::new();
    
   
    file_content.push_str("GitHub Skyline - ASCII Art Generator\n");
    file_content.push_str(&format!("Username: {}\n", username));
    file_content.push_str(&format!("Theme: {}\n", theme));
    file_content.push_str(&format!("Total Contributions: {}\n", total_contributions));
    file_content.push_str(&"=".repeat(80));
    file_content.push('\n');
    file_content.push('\n');
    
   
    let clean_output = strip_ansi_codes(skyline_output);
    file_content.push_str(&clean_output);
    
   
    file_content.push('\n');
    file_content.push_str(&"=".repeat(80));
    file_content.push('\n');
    file_content.push_str("Generated by GitHub Skyline - Transform your GitHub contributions into ASCII art!\n");
    file_content.push_str("https://github.com/yourusername/github-skyline\n");
    
   
    fs::write(filename, file_content)?;
    
    println!("{}", format!("âœ… Skyline saved to: {}", filename).bright_green().bold());
    println!("{}", format!("ğŸ“ File size: {} bytes", fs::metadata(filename)?.len()).bright_blue());
    
    Ok(())
}



fn strip_ansi_codes(text: &str) -> String {
   
    let ansi_regex = regex::Regex::new(r"\x1b\[[0-9;]*m").unwrap();
    ansi_regex.replace_all(text, "").to_string()
}


pub fn render_skyline_to_string(
    contributions: &[u32], 
    _theme: &str,
    _username: &str
) -> (String, u32) {

    use crate::renderer::building::get_max_height;
    use crate::renderer::sky_elements::select_moon_type;
    
    let mut output = String::new();
    let max_contributions = get_max_height(contributions);
    let total_contributions: u32 = contributions.iter().sum();
    
   
    output.push_str("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    output.push_str("â•‘                    ğŸš€ GITHUB SKYLINE GENERATOR ğŸš€             â•‘\n");
    output.push_str("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    output.push_str(&format!("ğŸ“ˆ Max daily contributions: {}\n", max_contributions));
    output.push('\n');
    
   
    output.push_str("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    output.push_str("â”‚                 BRAILLE-STYLE ASCII SKYLINE                 â”‚\n");
    output.push_str("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
    
   
    let building_heights: Vec<u32> = contributions
        .iter()
        .map(|&count| dramatic_scale(count, max_contributions))
        .collect();
    
    let _moon_type = select_moon_type(total_contributions);
    let max_height = *building_heights.iter().max().unwrap_or(&1) + 6;
    
   
    for _row in 0..15 {
        output.push_str("     ");
        for _col in 0..100 {
            if rand::random::<f32>() < 0.05 {
                output.push('*');
            } else {
                output.push(' ');
            }
        }
        output.push('\n');
    }
    

    let width = building_heights.len().min(25);
    for row in (1..=max_height).rev() {
        output.push_str("    ");
        for i in 0..width {
            let height = building_heights[i];
            if row <= height {
                if row == 1 {
                    output.push_str("â£¸â£¸â£¸");
                } else if row == height {
                    output.push_str("Â¯Â¯Â¯");
                } else {
                    output.push_str("â£¿â£¿â£¿");
                }
            } else {
                output.push_str("   ");
            }
            if i < width - 1 { output.push(' '); }
        }
        output.push('\n');
    }
    
    
    output.push_str("    ");
    for _i in 0..(width * 3 + width - 1) {
        output.push('~');
    }
    output.push('\n');
    
    
    output.push('\n');
    output.push_str("â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n");
    output.push_str("â”‚               ğŸ“Š CODING STATISTICS ğŸ“Š                       â”‚\n");
    output.push_str("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
    output.push_str(&format!("â”‚ ğŸ“… Total days tracked: {:>3}                              â”‚\n", contributions.len()));
    output.push_str(&format!("â”‚ ğŸ™ï¸  Days displayed:  {:>3}                                 â”‚\n", contributions.len().min(25)));
    output.push_str(&format!("â”‚ â­ Total contributions: {:>4}                             â”‚\n", total_contributions));
    output.push_str(&format!("â”‚ ğŸ”¥ Max daily contributions:  {:>3}                        â”‚\n", max_contributions));
    output.push_str("â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n");
    
    
    output.push('\n');
    let achievements = crate::achievements::calculate_achievements(contributions);
    if !achievements.is_empty() {
        output.push_str("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
        output.push_str("â•‘                    ğŸ† ACHIEVEMENTS UNLOCKED ğŸ†                â•‘\n");
        output.push_str("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        
        
        let legendary: Vec<_> = achievements.iter().filter(|a| a.tier == crate::achievements::Tier::Legendary).collect();
        let gold: Vec<_> = achievements.iter().filter(|a| a.tier == crate::achievements::Tier::Gold).collect();
        let silver: Vec<_> = achievements.iter().filter(|a| a.tier == crate::achievements::Tier::Silver).collect();
        let bronze: Vec<_> = achievements.iter().filter(|a| a.tier == crate::achievements::Tier::Bronze).collect();
        
        for (tier_name, tier_achievements) in [
            ("LEGENDARY", legendary),
            ("GOLD", gold),
            ("SILVER", silver),
            ("BRONZE", bronze)
        ] {
            if !tier_achievements.is_empty() {
                output.push_str(&format!("\nğŸ… {} TIER\n", tier_name));
                for achievement in tier_achievements {
                    output.push_str(&format!(
                        "   {} {} - {}\n",
                        achievement.icon,
                        achievement.name,
                        achievement.description
                    ));
                }
            }
        }
        
        output.push_str(&format!("\nğŸ–ï¸  Total Achievements Earned: {}\n", achievements.len()));
    }
    
    
    output.push('\n');
    output.push_str("â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“\n");
    output.push_str("         Your Braille-Style ASCII Architectural Year!         \n");
    output.push_str("         Share your beautiful terminal cityscape!           \n");
    output.push_str("â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“\n");
    
    (output, total_contributions)
}


fn dramatic_scale(contribution_count: u32, max_contributions: u32) -> u32 {
    if contribution_count == 0 { return 0; }
    
    let norm = contribution_count as f32 / max_contributions as f32;
    let dramatic = norm.powf(1.2);
    let scaled = (dramatic * 28.0) + 2.0;
    scaled.round() as u32
} 